import axios from 'axios';

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var check = function (it) {
  return it && it.Math == Math && it;
}; // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028


var global_1 = // eslint-disable-next-line no-undef
check(typeof globalThis == 'object' && globalThis) || check(typeof window == 'object' && window) || check(typeof self == 'object' && self) || check(typeof commonjsGlobal == 'object' && commonjsGlobal) || // eslint-disable-next-line no-new-func
Function('return this')();

var fails = function (exec) {
  try {
    return !!exec();
  } catch (error) {
    return true;
  }
};

var descriptors = !fails(function () {
  return Object.defineProperty({}, 'a', {
    get: function () {
      return 7;
    }
  }).a != 7;
});

var nativePropertyIsEnumerable = {}.propertyIsEnumerable;
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor; // Nashorn ~ JDK8 bug

var NASHORN_BUG = getOwnPropertyDescriptor && !nativePropertyIsEnumerable.call({
  1: 2
}, 1); // `Object.prototype.propertyIsEnumerable` method implementation
// https://tc39.github.io/ecma262/#sec-object.prototype.propertyisenumerable

var f = NASHORN_BUG ? function propertyIsEnumerable(V) {
  var descriptor = getOwnPropertyDescriptor(this, V);
  return !!descriptor && descriptor.enumerable;
} : nativePropertyIsEnumerable;
var objectPropertyIsEnumerable = {
  f: f
};

var createPropertyDescriptor = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};

var toString = {}.toString;

var classofRaw = function (it) {
  return toString.call(it).slice(8, -1);
};

var split = ''.split; // fallback for non-array-like ES3 and non-enumerable old V8 strings

var indexedObject = fails(function () {
  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
  // eslint-disable-next-line no-prototype-builtins
  return !Object('z').propertyIsEnumerable(0);
}) ? function (it) {
  return classofRaw(it) == 'String' ? split.call(it, '') : Object(it);
} : Object;

// `RequireObjectCoercible` abstract operation
// https://tc39.github.io/ecma262/#sec-requireobjectcoercible
var requireObjectCoercible = function (it) {
  if (it == undefined) throw TypeError("Can't call method on " + it);
  return it;
};

var toIndexedObject = function (it) {
  return indexedObject(requireObjectCoercible(it));
};

var isObject = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};

// https://tc39.github.io/ecma262/#sec-toprimitive
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string

var toPrimitive = function (input, PREFERRED_STRING) {
  if (!isObject(input)) return input;
  var fn, val;
  if (PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) return val;
  if (typeof (fn = input.valueOf) == 'function' && !isObject(val = fn.call(input))) return val;
  if (!PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) return val;
  throw TypeError("Can't convert object to primitive value");
};

var hasOwnProperty = {}.hasOwnProperty;

var has = function (it, key) {
  return hasOwnProperty.call(it, key);
};

var document = global_1.document; // typeof document.createElement is 'object' in old IE

var EXISTS = isObject(document) && isObject(document.createElement);

var documentCreateElement = function (it) {
  return EXISTS ? document.createElement(it) : {};
};

var ie8DomDefine = !descriptors && !fails(function () {
  return Object.defineProperty(documentCreateElement('div'), 'a', {
    get: function () {
      return 7;
    }
  }).a != 7;
});

var nativeGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor; // `Object.getOwnPropertyDescriptor` method
// https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptor

var f$1 = descriptors ? nativeGetOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
  O = toIndexedObject(O);
  P = toPrimitive(P, true);
  if (ie8DomDefine) try {
    return nativeGetOwnPropertyDescriptor(O, P);
  } catch (error) {
    /* empty */
  }
  if (has(O, P)) return createPropertyDescriptor(!objectPropertyIsEnumerable.f.call(O, P), O[P]);
};
var objectGetOwnPropertyDescriptor = {
  f: f$1
};

var anObject = function (it) {
  if (!isObject(it)) {
    throw TypeError(String(it) + ' is not an object');
  }

  return it;
};

var nativeDefineProperty = Object.defineProperty; // `Object.defineProperty` method
// https://tc39.github.io/ecma262/#sec-object.defineproperty

var f$2 = descriptors ? nativeDefineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (ie8DomDefine) try {
    return nativeDefineProperty(O, P, Attributes);
  } catch (error) {
    /* empty */
  }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};
var objectDefineProperty = {
  f: f$2
};

var createNonEnumerableProperty = descriptors ? function (object, key, value) {
  return objectDefineProperty.f(object, key, createPropertyDescriptor(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};

var setGlobal = function (key, value) {
  try {
    createNonEnumerableProperty(global_1, key, value);
  } catch (error) {
    global_1[key] = value;
  }

  return value;
};

var SHARED = '__core-js_shared__';
var store = global_1[SHARED] || setGlobal(SHARED, {});
var sharedStore = store;

var shared = createCommonjsModule(function (module) {
  (module.exports = function (key, value) {
    return sharedStore[key] || (sharedStore[key] = value !== undefined ? value : {});
  })('versions', []).push({
    version: '3.4.4',
    mode:  'global',
    copyright: 'Â© 2019 Denis Pushkarev (zloirock.ru)'
  });
});

var functionToString = shared('native-function-to-string', Function.toString);

var WeakMap = global_1.WeakMap;
var nativeWeakMap = typeof WeakMap === 'function' && /native code/.test(functionToString.call(WeakMap));

var id = 0;
var postfix = Math.random();

var uid = function (key) {
  return 'Symbol(' + String(key === undefined ? '' : key) + ')_' + (++id + postfix).toString(36);
};

var keys = shared('keys');

var sharedKey = function (key) {
  return keys[key] || (keys[key] = uid(key));
};

var hiddenKeys = {};

var WeakMap$1 = global_1.WeakMap;
var set, get, has$1;

var enforce = function (it) {
  return has$1(it) ? get(it) : set(it, {});
};

var getterFor = function (TYPE) {
  return function (it) {
    var state;

    if (!isObject(it) || (state = get(it)).type !== TYPE) {
      throw TypeError('Incompatible receiver, ' + TYPE + ' required');
    }

    return state;
  };
};

if (nativeWeakMap) {
  var store$1 = new WeakMap$1();
  var wmget = store$1.get;
  var wmhas = store$1.has;
  var wmset = store$1.set;

  set = function (it, metadata) {
    wmset.call(store$1, it, metadata);
    return metadata;
  };

  get = function (it) {
    return wmget.call(store$1, it) || {};
  };

  has$1 = function (it) {
    return wmhas.call(store$1, it);
  };
} else {
  var STATE = sharedKey('state');
  hiddenKeys[STATE] = true;

  set = function (it, metadata) {
    createNonEnumerableProperty(it, STATE, metadata);
    return metadata;
  };

  get = function (it) {
    return has(it, STATE) ? it[STATE] : {};
  };

  has$1 = function (it) {
    return has(it, STATE);
  };
}

var internalState = {
  set: set,
  get: get,
  has: has$1,
  enforce: enforce,
  getterFor: getterFor
};

var redefine = createCommonjsModule(function (module) {
  var getInternalState = internalState.get;
  var enforceInternalState = internalState.enforce;
  var TEMPLATE = String(functionToString).split('toString');
  shared('inspectSource', function (it) {
    return functionToString.call(it);
  });
  (module.exports = function (O, key, value, options) {
    var unsafe = options ? !!options.unsafe : false;
    var simple = options ? !!options.enumerable : false;
    var noTargetGet = options ? !!options.noTargetGet : false;

    if (typeof value == 'function') {
      if (typeof key == 'string' && !has(value, 'name')) createNonEnumerableProperty(value, 'name', key);
      enforceInternalState(value).source = TEMPLATE.join(typeof key == 'string' ? key : '');
    }

    if (O === global_1) {
      if (simple) O[key] = value;else setGlobal(key, value);
      return;
    } else if (!unsafe) {
      delete O[key];
    } else if (!noTargetGet && O[key]) {
      simple = true;
    }

    if (simple) O[key] = value;else createNonEnumerableProperty(O, key, value); // add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
  })(Function.prototype, 'toString', function toString() {
    return typeof this == 'function' && getInternalState(this).source || functionToString.call(this);
  });
});

var path = global_1;

var aFunction = function (variable) {
  return typeof variable == 'function' ? variable : undefined;
};

var getBuiltIn = function (namespace, method) {
  return arguments.length < 2 ? aFunction(path[namespace]) || aFunction(global_1[namespace]) : path[namespace] && path[namespace][method] || global_1[namespace] && global_1[namespace][method];
};

var ceil = Math.ceil;
var floor = Math.floor; // `ToInteger` abstract operation
// https://tc39.github.io/ecma262/#sec-tointeger

var toInteger = function (argument) {
  return isNaN(argument = +argument) ? 0 : (argument > 0 ? floor : ceil)(argument);
};

var min = Math.min; // `ToLength` abstract operation
// https://tc39.github.io/ecma262/#sec-tolength

var toLength = function (argument) {
  return argument > 0 ? min(toInteger(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991
};

var max = Math.max;
var min$1 = Math.min; // Helper for a popular repeating case of the spec:
// Let integer be ? ToInteger(index).
// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).

var toAbsoluteIndex = function (index, length) {
  var integer = toInteger(index);
  return integer < 0 ? max(integer + length, 0) : min$1(integer, length);
};

var createMethod = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIndexedObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value; // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare

    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++]; // eslint-disable-next-line no-self-compare

      if (value != value) return true; // Array#indexOf ignores holes, Array#includes - not
    } else for (; length > index; index++) {
      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
    }
    return !IS_INCLUDES && -1;
  };
};

var arrayIncludes = {
  // `Array.prototype.includes` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.includes
  includes: createMethod(true),
  // `Array.prototype.indexOf` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.indexof
  indexOf: createMethod(false)
};

var indexOf = arrayIncludes.indexOf;

var objectKeysInternal = function (object, names) {
  var O = toIndexedObject(object);
  var i = 0;
  var result = [];
  var key;

  for (key in O) !has(hiddenKeys, key) && has(O, key) && result.push(key); // Don't enum bug & hidden keys


  while (names.length > i) if (has(O, key = names[i++])) {
    ~indexOf(result, key) || result.push(key);
  }

  return result;
};

// IE8- don't enum bug keys
var enumBugKeys = ['constructor', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'toLocaleString', 'toString', 'valueOf'];

var hiddenKeys$1 = enumBugKeys.concat('length', 'prototype'); // `Object.getOwnPropertyNames` method
// https://tc39.github.io/ecma262/#sec-object.getownpropertynames

var f$3 = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return objectKeysInternal(O, hiddenKeys$1);
};

var objectGetOwnPropertyNames = {
  f: f$3
};

var f$4 = Object.getOwnPropertySymbols;
var objectGetOwnPropertySymbols = {
  f: f$4
};

var ownKeys = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {
  var keys = objectGetOwnPropertyNames.f(anObject(it));
  var getOwnPropertySymbols = objectGetOwnPropertySymbols.f;
  return getOwnPropertySymbols ? keys.concat(getOwnPropertySymbols(it)) : keys;
};

var copyConstructorProperties = function (target, source) {
  var keys = ownKeys(source);
  var defineProperty = objectDefineProperty.f;
  var getOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;

  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    if (!has(target, key)) defineProperty(target, key, getOwnPropertyDescriptor(source, key));
  }
};

var replacement = /#|\.prototype\./;

var isForced = function (feature, detection) {
  var value = data[normalize(feature)];
  return value == POLYFILL ? true : value == NATIVE ? false : typeof detection == 'function' ? fails(detection) : !!detection;
};

var normalize = isForced.normalize = function (string) {
  return String(string).replace(replacement, '.').toLowerCase();
};

var data = isForced.data = {};
var NATIVE = isForced.NATIVE = 'N';
var POLYFILL = isForced.POLYFILL = 'P';
var isForced_1 = isForced;

var getOwnPropertyDescriptor$1 = objectGetOwnPropertyDescriptor.f;
/*
  options.target      - name of the target object
  options.global      - target is the global object
  options.stat        - export as static methods of target
  options.proto       - export as prototype methods of target
  options.real        - real prototype method for the `pure` version
  options.forced      - export even if the native feature is available
  options.bind        - bind methods to the target, required for the `pure` version
  options.wrap        - wrap constructors to preventing global pollution, required for the `pure` version
  options.unsafe      - use the simple assignment of property instead of delete + defineProperty
  options.sham        - add a flag to not completely full polyfills
  options.enumerable  - export as enumerable property
  options.noTargetGet - prevent calling a getter on target
*/

var _export = function (options, source) {
  var TARGET = options.target;
  var GLOBAL = options.global;
  var STATIC = options.stat;
  var FORCED, target, key, targetProperty, sourceProperty, descriptor;

  if (GLOBAL) {
    target = global_1;
  } else if (STATIC) {
    target = global_1[TARGET] || setGlobal(TARGET, {});
  } else {
    target = (global_1[TARGET] || {}).prototype;
  }

  if (target) for (key in source) {
    sourceProperty = source[key];

    if (options.noTargetGet) {
      descriptor = getOwnPropertyDescriptor$1(target, key);
      targetProperty = descriptor && descriptor.value;
    } else targetProperty = target[key];

    FORCED = isForced_1(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced); // contained in target

    if (!FORCED && targetProperty !== undefined) {
      if (typeof sourceProperty === typeof targetProperty) continue;
      copyConstructorProperties(sourceProperty, targetProperty);
    } // add a flag to not completely full polyfills


    if (options.sham || targetProperty && targetProperty.sham) {
      createNonEnumerableProperty(sourceProperty, 'sham', true);
    } // extend global


    redefine(target, key, sourceProperty, options);
  }
};

var aFunction$1 = function (it) {
  if (typeof it != 'function') {
    throw TypeError(String(it) + ' is not a function');
  }

  return it;
};

var bindContext = function (fn, that, length) {
  aFunction$1(fn);
  if (that === undefined) return fn;

  switch (length) {
    case 0:
      return function () {
        return fn.call(that);
      };

    case 1:
      return function (a) {
        return fn.call(that, a);
      };

    case 2:
      return function (a, b) {
        return fn.call(that, a, b);
      };

    case 3:
      return function (a, b, c) {
        return fn.call(that, a, b, c);
      };
  }

  return function ()
  /* ...args */
  {
    return fn.apply(that, arguments);
  };
};

var html = getBuiltIn('document', 'documentElement');

var userAgent = getBuiltIn('navigator', 'userAgent') || '';

var isIos = /(iphone|ipod|ipad).*applewebkit/i.test(userAgent);

var location = global_1.location;
var set$1 = global_1.setImmediate;
var clear = global_1.clearImmediate;
var process = global_1.process;
var MessageChannel = global_1.MessageChannel;
var Dispatch = global_1.Dispatch;
var counter = 0;
var queue = {};
var ONREADYSTATECHANGE = 'onreadystatechange';
var defer, channel, port;

var run = function (id) {
  // eslint-disable-next-line no-prototype-builtins
  if (queue.hasOwnProperty(id)) {
    var fn = queue[id];
    delete queue[id];
    fn();
  }
};

var runner = function (id) {
  return function () {
    run(id);
  };
};

var listener = function (event) {
  run(event.data);
};

var post = function (id) {
  // old engines have not location.origin
  global_1.postMessage(id + '', location.protocol + '//' + location.host);
}; // Node.js 0.9+ & IE10+ has setImmediate, otherwise:


if (!set$1 || !clear) {
  set$1 = function setImmediate(fn) {
    var args = [];
    var i = 1;

    while (arguments.length > i) args.push(arguments[i++]);

    queue[++counter] = function () {
      // eslint-disable-next-line no-new-func
      (typeof fn == 'function' ? fn : Function(fn)).apply(undefined, args);
    };

    defer(counter);
    return counter;
  };

  clear = function clearImmediate(id) {
    delete queue[id];
  }; // Node.js 0.8-


  if (classofRaw(process) == 'process') {
    defer = function (id) {
      process.nextTick(runner(id));
    }; // Sphere (JS game engine) Dispatch API

  } else if (Dispatch && Dispatch.now) {
    defer = function (id) {
      Dispatch.now(runner(id));
    }; // Browsers with MessageChannel, includes WebWorkers
    // except iOS - https://github.com/zloirock/core-js/issues/624

  } else if (MessageChannel && !isIos) {
    channel = new MessageChannel();
    port = channel.port2;
    channel.port1.onmessage = listener;
    defer = bindContext(port.postMessage, port, 1); // Browsers with postMessage, skip WebWorkers
    // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
  } else if (global_1.addEventListener && typeof postMessage == 'function' && !global_1.importScripts && !fails(post)) {
    defer = post;
    global_1.addEventListener('message', listener, false); // IE8-
  } else if (ONREADYSTATECHANGE in documentCreateElement('script')) {
    defer = function (id) {
      html.appendChild(documentCreateElement('script'))[ONREADYSTATECHANGE] = function () {
        html.removeChild(this);
        run(id);
      };
    }; // Rest old browsers

  } else {
    defer = function (id) {
      setTimeout(runner(id), 0);
    };
  }
}

var task = {
  set: set$1,
  clear: clear
};

var FORCED = !global_1.setImmediate || !global_1.clearImmediate; // http://w3c.github.io/setImmediate/

_export({
  global: true,
  bind: true,
  enumerable: true,
  forced: FORCED
}, {
  // `setImmediate` method
  // http://w3c.github.io/setImmediate/#si-setImmediate
  setImmediate: task.set,
  // `clearImmediate` method
  // http://w3c.github.io/setImmediate/#si-clearImmediate
  clearImmediate: task.clear
});

var setImmediate$1 = path.setImmediate;

var version = "1.1.1";

function _typeof(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _possibleConstructorReturn(self, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _superPropBase(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf(object);
    if (object === null) break;
  }

  return object;
}

function _get(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get = Reflect.get;
  } else {
    _get = function _get(target, property, receiver) {
      var base = _superPropBase(target, property);

      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property);

      if (desc.get) {
        return desc.get.call(receiver);
      }

      return desc.value;
    };
  }

  return _get(target, property, receiver || target);
}

var eventemitter3 = createCommonjsModule(function (module) {

  var has = Object.prototype.hasOwnProperty,
      prefix = '~';
  /**
   * Constructor to create a storage for our `EE` objects.
   * An `Events` instance is a plain object whose properties are event names.
   *
   * @constructor
   * @private
   */

  function Events() {} //
  // We try to not inherit from `Object.prototype`. In some engines creating an
  // instance in this way is faster than calling `Object.create(null)` directly.
  // If `Object.create(null)` is not supported we prefix the event names with a
  // character to make sure that the built-in object properties are not
  // overridden or used as an attack vector.
  //


  if (Object.create) {
    Events.prototype = Object.create(null); //
    // This hack is needed because the `__proto__` property is still inherited in
    // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.
    //

    if (!new Events().__proto__) prefix = false;
  }
  /**
   * Representation of a single event listener.
   *
   * @param {Function} fn The listener function.
   * @param {*} context The context to invoke the listener with.
   * @param {Boolean} [once=false] Specify if the listener is a one-time listener.
   * @constructor
   * @private
   */


  function EE(fn, context, once) {
    this.fn = fn;
    this.context = context;
    this.once = once || false;
  }
  /**
   * Add a listener for a given event.
   *
   * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
   * @param {(String|Symbol)} event The event name.
   * @param {Function} fn The listener function.
   * @param {*} context The context to invoke the listener with.
   * @param {Boolean} once Specify if the listener is a one-time listener.
   * @returns {EventEmitter}
   * @private
   */


  function addListener(emitter, event, fn, context, once) {
    if (typeof fn !== 'function') {
      throw new TypeError('The listener must be a function');
    }

    var listener = new EE(fn, context || emitter, once),
        evt = prefix ? prefix + event : event;
    if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);else emitter._events[evt] = [emitter._events[evt], listener];
    return emitter;
  }
  /**
   * Clear event by name.
   *
   * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
   * @param {(String|Symbol)} evt The Event name.
   * @private
   */


  function clearEvent(emitter, evt) {
    if (--emitter._eventsCount === 0) emitter._events = new Events();else delete emitter._events[evt];
  }
  /**
   * Minimal `EventEmitter` interface that is molded against the Node.js
   * `EventEmitter` interface.
   *
   * @constructor
   * @public
   */


  function EventEmitter() {
    this._events = new Events();
    this._eventsCount = 0;
  }
  /**
   * Return an array listing the events for which the emitter has registered
   * listeners.
   *
   * @returns {Array}
   * @public
   */


  EventEmitter.prototype.eventNames = function eventNames() {
    var names = [],
        events,
        name;
    if (this._eventsCount === 0) return names;

    for (name in events = this._events) {
      if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
    }

    if (Object.getOwnPropertySymbols) {
      return names.concat(Object.getOwnPropertySymbols(events));
    }

    return names;
  };
  /**
   * Return the listeners registered for a given event.
   *
   * @param {(String|Symbol)} event The event name.
   * @returns {Array} The registered listeners.
   * @public
   */


  EventEmitter.prototype.listeners = function listeners(event) {
    var evt = prefix ? prefix + event : event,
        handlers = this._events[evt];
    if (!handlers) return [];
    if (handlers.fn) return [handlers.fn];

    for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
      ee[i] = handlers[i].fn;
    }

    return ee;
  };
  /**
   * Return the number of listeners listening to a given event.
   *
   * @param {(String|Symbol)} event The event name.
   * @returns {Number} The number of listeners.
   * @public
   */


  EventEmitter.prototype.listenerCount = function listenerCount(event) {
    var evt = prefix ? prefix + event : event,
        listeners = this._events[evt];
    if (!listeners) return 0;
    if (listeners.fn) return 1;
    return listeners.length;
  };
  /**
   * Calls each of the listeners registered for a given event.
   *
   * @param {(String|Symbol)} event The event name.
   * @returns {Boolean} `true` if the event had listeners, else `false`.
   * @public
   */


  EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
    var evt = prefix ? prefix + event : event;
    if (!this._events[evt]) return false;
    var listeners = this._events[evt],
        len = arguments.length,
        args,
        i;

    if (listeners.fn) {
      if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);

      switch (len) {
        case 1:
          return listeners.fn.call(listeners.context), true;

        case 2:
          return listeners.fn.call(listeners.context, a1), true;

        case 3:
          return listeners.fn.call(listeners.context, a1, a2), true;

        case 4:
          return listeners.fn.call(listeners.context, a1, a2, a3), true;

        case 5:
          return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;

        case 6:
          return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
      }

      for (i = 1, args = new Array(len - 1); i < len; i++) {
        args[i - 1] = arguments[i];
      }

      listeners.fn.apply(listeners.context, args);
    } else {
      var length = listeners.length,
          j;

      for (i = 0; i < length; i++) {
        if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);

        switch (len) {
          case 1:
            listeners[i].fn.call(listeners[i].context);
            break;

          case 2:
            listeners[i].fn.call(listeners[i].context, a1);
            break;

          case 3:
            listeners[i].fn.call(listeners[i].context, a1, a2);
            break;

          case 4:
            listeners[i].fn.call(listeners[i].context, a1, a2, a3);
            break;

          default:
            if (!args) for (j = 1, args = new Array(len - 1); j < len; j++) {
              args[j - 1] = arguments[j];
            }
            listeners[i].fn.apply(listeners[i].context, args);
        }
      }
    }

    return true;
  };
  /**
   * Add a listener for a given event.
   *
   * @param {(String|Symbol)} event The event name.
   * @param {Function} fn The listener function.
   * @param {*} [context=this] The context to invoke the listener with.
   * @returns {EventEmitter} `this`.
   * @public
   */


  EventEmitter.prototype.on = function on(event, fn, context) {
    return addListener(this, event, fn, context, false);
  };
  /**
   * Add a one-time listener for a given event.
   *
   * @param {(String|Symbol)} event The event name.
   * @param {Function} fn The listener function.
   * @param {*} [context=this] The context to invoke the listener with.
   * @returns {EventEmitter} `this`.
   * @public
   */


  EventEmitter.prototype.once = function once(event, fn, context) {
    return addListener(this, event, fn, context, true);
  };
  /**
   * Remove the listeners of a given event.
   *
   * @param {(String|Symbol)} event The event name.
   * @param {Function} fn Only remove the listeners that match this function.
   * @param {*} context Only remove the listeners that have this context.
   * @param {Boolean} once Only remove one-time listeners.
   * @returns {EventEmitter} `this`.
   * @public
   */


  EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
    var evt = prefix ? prefix + event : event;
    if (!this._events[evt]) return this;

    if (!fn) {
      clearEvent(this, evt);
      return this;
    }

    var listeners = this._events[evt];

    if (listeners.fn) {
      if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
        clearEvent(this, evt);
      }
    } else {
      for (var i = 0, events = [], length = listeners.length; i < length; i++) {
        if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
          events.push(listeners[i]);
        }
      } //
      // Reset the array, or remove it completely if we have no more listeners.
      //


      if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;else clearEvent(this, evt);
    }

    return this;
  };
  /**
   * Remove all listeners, or those of the specified event.
   *
   * @param {(String|Symbol)} [event] The event name.
   * @returns {EventEmitter} `this`.
   * @public
   */


  EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
    var evt;

    if (event) {
      evt = prefix ? prefix + event : event;
      if (this._events[evt]) clearEvent(this, evt);
    } else {
      this._events = new Events();
      this._eventsCount = 0;
    }

    return this;
  }; //
  // Alias methods names because people roll like that.
  //


  EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
  EventEmitter.prototype.addListener = EventEmitter.prototype.on; //
  // Expose the prefix.
  //

  EventEmitter.prefixed = prefix; //
  // Allow `EventEmitter` to be imported as module namespace.
  //

  EventEmitter.EventEmitter = EventEmitter; //
  // Expose the module.
  //

  {
    module.exports = EventEmitter;
  }
});

var IsEmptyObject = function IsEmptyObject(obj) {
  return obj && obj.constructor === Object && Object.keys(obj).length === 0;
};

var RandomStr = function RandomStr() {
  var len = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 8;
  var charts = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('');
  var s = '';

  for (var i = 0; i < len; i++) {
    s += charts[Math.random() * 0x3e | 0];
  }

  return s;
};

function _genList(str) {
  // string æ ¹æ® | åå²ä¸ºæ°ç»
  var list = [];
  var items = str.split('|');

  for (var i = 0; i < items.length; i++) {
    list.push(items[i].trim()); // NOTE: æäºç«çº¿ä¹é´åå®¹ä¸ºç©º
  }

  return list;
}

function _genItem(keys, values) {
  // æ ¹æ® keys - values è¿å object
  var item = {};

  for (var j = 0; j < keys.length; j++) {
    item[keys[j]] = values[j];
  }

  return item;
}

function _genTableRow(state, stateDetail, colNames, line) {
  // æ ¹æ® åæ° å¤çè¡¨æ ¼çä¸è¡
  var result = {
    state: state,
    state_detail: stateDetail,
    isRow: false,
    row: null
  };

  switch (stateDetail) {
    case 'T':
      // title
      if (line.replace(/-/g, '') === '') {
        result.state_detail = 'C';
      } else {
        colNames[state] = _genList(line);
      }

      break;

    case 'C':
      // content
      if (line.replace(/-/g, '') === '') {
        result.state_detail = 'S';
      } else {
        result.isRow = true;
        result.row = _genItem(colNames[state], _genList(line));
      }

      break;

    case 'S':
      if (line.replace(/-/g, '') === '') {
        result.state = '';
        result.state_detail = '';
      }

      break;
  }

  return result;
}

var ParseSettlementContent = function ParseSettlementContent() {
  var txt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  if (txt === '') return txt;
  var lines = txt.split('\n');
  var state = ''; // A = Account Summary; T = Transaction Record; PD = Positions Detail; P = Positions

  var stateDetail = ''; // T = title; C = content; S = summary

  var colNames = {}; // éè¦å¤ççè¡¨æ ¼

  var tableStatesTitles = {
    positionClosed: 'å¹³ä»æç» Position Closed',
    transactionRecords: 'æäº¤è®°å½ Transaction Record',
    positions: 'æä»æ±æ» Positions',
    positionsDetail: 'æä»æç» Positions Detail',
    delivery: 'äº¤å²æç»  Delivery'
  };
  var states = [];
  var titles = [];
  var result = {
    account: {}
  };
  Object.entries(tableStatesTitles).forEach(function (item) {
    states.push(item[0]);
    titles.push(item[1]);
    result[item[0]] = [];
  });

  for (var i = 0; i < lines.length; i++) {
    var line = lines[i].trim();

    if (line === 'èµéç¶åµ  å¸ç§ï¼äººæ°å¸  Account Summary  Currencyï¼CNY') {
      state = 'A-S';
      i++;
      continue;
    } else if (titles.includes(line)) {
      state = states[titles.indexOf(line)];
      stateDetail = 'T';
      i++;
      continue;
    }

    if (state === 'A-S') {
      if (line.length === 0 || line.replace('-', '') === '') {
        state = '';
        continue;
      } else {
        // eslint-disable-next-line no-unused-vars
        var chMatches = line.match(/([\u4e00-\u9fa5][\u4e00-\u9fa5\s]+[\u4e00-\u9fa5])+/g); // ä¸­æ
        // eslint-disable-next-line no-useless-escape

        var enMatches = line.match(/([A-Z][a-zA-Z\.\/\(\)\s]+)[:ï¼]+/g); // è±æ

        var numMatches = line.match(/(-?[\d]+\.\d\d)/g); // æ°å­

        for (var j = 0; j < enMatches.length; j++) {
          result.account[enMatches[j].split(/[:ï¼]/)[0]] = numMatches[j];
        }
      }
    } else if (states.includes(state)) {
      if (line.length === 0) {
        state = '';
        continue;
      } else {
        var tableRow = _genTableRow(state, stateDetail, colNames, line);

        state = tableRow.state;
        stateDetail = tableRow.state_detail;

        if (tableRow.isRow) {
          result[state].push(tableRow.row);
        }
      }
    }
  }

  return result;
};

/**
 * let ws = new TqWebsocket(url, options)
 * PARAMS:
 *   url [string | array]
 *   options [object]
 *       { reconnectInterval, -- éè¿æ¶é´é´é
 *        reconnectMaxTimes  -- éè¿æå¤§æ¬¡æ°
 *       }
 *
 * METHODS:
 *   ws.init()
 *   ws.on(eventName, (data) => {......})
 *      eventName =
 *      ['message', -- æ¶å°ä¿¡æ¯
 *       'open', -- è¿æ¥å»ºç«
 *       'reconnect', -- éæ°å¼å§å»ºç«è¿æ¥
 *       'close', -- æä¸ªè¿æ¥å³é­
 *       'error', -- æä¸ªè¿æ¥æ¥é
 *       'death' -- ä¸åéè¿
 *      ]
 *   ws.send( [obj | string] )
 *   ws.close()
 */

var TqWebsocket =
/*#__PURE__*/
function (_EventEmitter) {
  _inherits(TqWebsocket, _EventEmitter);

  function TqWebsocket(url) {
    var _this2;

    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, TqWebsocket);

    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(TqWebsocket).call(this));
    _this2.urlList = url instanceof Array ? url : [url];
    _this2.ws = null;
    _this2.queue = []; // èªå¨éè¿å¼å³

    _this2.reconnect = true;
    _this2.reconnectTask = null;
    _this2.reconnectInterval = options.reconnectInterval ? options.reconnectInterval : 3000;
    _this2.reconnectMaxTimes = options.reconnectMaxTimes ? options.reconnectMaxTimes : 5;
    _this2.reconnectTimes = 0;
    _this2.reconnectUrlIndex = 0;
    _this2.STATUS = {
      CONNECTING: 0,
      OPEN: 1,
      CLOSING: 2,
      CLOSED: 3
    };

    _this2.__init();

    return _this2;
  } // string or object


  _createClass(TqWebsocket, [{
    key: "send",
    value: function send(obj) {
      var objToJson = JSON.stringify(obj);

      if (this.isReady()) {
        this.ws.send(objToJson);
      } else {
        this.queue.push(objToJson);
      }
    }
  }, {
    key: "isReady",
    value: function isReady() {
      return this.ws.readyState === WebSocket.OPEN;
    }
  }, {
    key: "__init",
    value: function __init() {
      this.ws = new WebSocket(this.urlList[this.reconnectUrlIndex]);

      if (this.reconnectUrlIndex === this.urlList.length - 1) {
        // urlList å¾ªç¯å°è¯éè¿ä¸è½®, times += 1
        this.reconnectTimes += 1;
      }

      var _this = this;

      this.ws.onmessage = function (message) {
        // eslint-disable-next-line no-eval
        var data = eval('(' + message.data + ')');

        _this.emit('message', data);

        setImmediate(function () {
          _this.ws.send('{"aid":"peek_message"}');
        });
      };

      this.ws.onclose = function (event) {
        console.log('close', event);

        _this.emit('close'); // æ¸ç©º queue


        _this.queue = []; // èªå¨éè¿

        if (_this.reconnect) {
          if (_this.reconnectMaxTimes <= _this.reconnectTimes) {
            clearTimeout(_this.reconnectTask);

            _this.emit('death', {
              msg: 'è¶è¿éè¿æ¬¡æ°' + _this.reconnectMaxTimes
            });
          } else {
            _this.reconnectTask = setTimeout(function () {
              if (_this.ws.readyState === 3) {
                // æ¯æ¬¡éè¿çæ¶åè®¾ç½® _this.reconnectUrlIndex
                _this.reconnectUrlIndex = _this.reconnectUrlIndex + 1 < _this.urlList.length ? _this.reconnectUrlIndex + 1 : 0;

                _this.__init();

                _this.emit('reconnect', {
                  msg: 'åèµ·éè¿ç¬¬ ' + _this.reconnectTimes + ' æ¬¡'
                });
              }
            }, _this.reconnectInterval);
          }
        }
      };

      this.ws.onerror = function (error) {
        _this.emit('error', error);

        _this.ws.close();
      };

      this.ws.onopen = function () {
        _this.emit('open', {
          msg: 'åèµ·éè¿ç¬¬ ' + _this.reconnectTimes + ' æ¬¡, æå'
        });

        _this.reconnectTimes = 0;
        _this.reconnectUrlIndex = 0;

        if (this.reconnectTask) {
          clearTimeout(_this.reconnectTask);
        }

        while (_this.queue.length > 0) {
          if (_this.ws.readyState === 1) _this.ws.send(_this.queue.shift());else break;
        }
      };
    }
  }, {
    key: "close",
    value: function close() {
      this.ws.onclose = function () {};

      this.ws.close();
    }
  }]);

  return TqWebsocket;
}(eventemitter3);

var TqTradeWebsocket =
/*#__PURE__*/
function (_TqWebsocket) {
  _inherits(TqTradeWebsocket, _TqWebsocket);

  function TqTradeWebsocket(url, dm) {
    var _this3;

    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    _classCallCheck(this, TqTradeWebsocket);

    _this3 = _possibleConstructorReturn(this, _getPrototypeOf(TqTradeWebsocket).call(this, url, options));
    _this3.dm = dm; // è®°å½éè¿æ¶éè¦éåçæ°æ®

    _this3.req_login = null;

    _this3.init();

    return _this3;
  }

  _createClass(TqTradeWebsocket, [{
    key: "init",
    value: function init() {
      var self = this;
      this.on('message', function (payload) {
        if (payload.aid === 'rtn_data') {
          var notifies = self._separateNotifies(payload.data);

          for (var i = 0; i < notifies.length; i++) {
            self.emit('notify', notifies[i]);
          }

          self.dm.mergeData(payload.data);
        } else if (payload.aid === 'rtn_brokers') {
          self.emit('rtn_brokers', payload.brokers);
        } else if (payload.aid === 'qry_settlement_info') {
          // åå²ç»ç®å è¯»åä¼åçº§ï¼ dm -> ç¼å­(åå¥dm) -> æå¡å¨(åå¥dmãç¼å­)
          var content = ParseSettlementContent(payload.settlement_info); // 1 åå¥ dm

          self.dm.mergeData({
            trade: _defineProperty({}, payload.user_name, {
              his_settlements: _defineProperty({}, payload.trading_day, content)
            })
          }); // 2 å­å¥ç¼å­

          if (TQSDK.store) TQSDK.store.setContent(payload.user_name, payload.trading_day, payload.settlement_info);
        }
      });
      this.on('reconnect', function () {
        if (self.req_login) self.send(self.req_login);
      });
    }
  }, {
    key: "_separateNotifies",
    value: function _separateNotifies(data) {
      var notifies = [];

      for (var i = 0; i < data.length; i++) {
        if (data[i].notify) {
          var notify = data.splice(i--, 1)[0].notify;

          for (var k in notify) {
            notifies.push(notify[k]);
          }
        }
      }

      return notifies;
    }
  }, {
    key: "send",
    value: function send(obj) {
      if (obj.aid === 'req_login') {
        this.req_login = obj;
      }

      _get(_getPrototypeOf(TqTradeWebsocket.prototype), "send", this).call(this, obj);
    }
  }]);

  return TqTradeWebsocket;
}(TqWebsocket);

var TqQuoteWebsocket =
/*#__PURE__*/
function (_TqWebsocket2) {
  _inherits(TqQuoteWebsocket, _TqWebsocket2);

  function TqQuoteWebsocket(url, dm) {
    var _this4;

    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    _classCallCheck(this, TqQuoteWebsocket);

    _this4 = _possibleConstructorReturn(this, _getPrototypeOf(TqQuoteWebsocket).call(this, url, options));
    _this4.dm = dm; // è®°å½éè¿æ¶éè¦éåçæ°æ®

    _this4.subscribe_quote = null;
    _this4.charts = {};

    _this4.init();

    return _this4;
  }

  _createClass(TqQuoteWebsocket, [{
    key: "init",
    value: function init() {
      var self = this;
      this.on('message', function (payload) {
        if (payload.aid === 'rtn_data') {
          self.dm.mergeData(payload.data);
        }
      });
      this.on('reconnect', function (e) {
        console.log(e);

        if (self.subscribe_quote) {
          self.send(self.subscribe_quote);
        }

        for (var chartId in self.charts) {
          if (self.charts[chartId].view_width > 0) {
            self.send(self.charts[chartId]);
          }
        }
      });
    }
  }, {
    key: "send",
    value: function send(obj) {
      if (obj.aid === 'subscribe_quote') {
        if (this.subscribe_quote === null || JSON.stringify(obj.ins_list) !== JSON.stringify(this.subscribe_quote.ins_list)) {
          this.subscribe_quote = obj;

          _get(_getPrototypeOf(TqQuoteWebsocket.prototype), "send", this).call(this, obj);
        }
      } else if (obj.aid === 'set_chart') {
        if (obj.view_width === 0) {
          if (this.charts[obj.chart_id]) delete this.charts[obj.chart_id];
        } else {
          this.charts[obj.chart_id] = obj;
        }

        _get(_getPrototypeOf(TqQuoteWebsocket.prototype), "send", this).call(this, obj);
      }
    }
  }]);

  return TqQuoteWebsocket;
}(TqWebsocket);

var TqRecvOnlyWebsocket =
/*#__PURE__*/
function (_TqWebsocket3) {
  _inherits(TqRecvOnlyWebsocket, _TqWebsocket3);

  function TqRecvOnlyWebsocket(url, dm) {
    var _this5;

    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    _classCallCheck(this, TqRecvOnlyWebsocket);

    _this5 = _possibleConstructorReturn(this, _getPrototypeOf(TqRecvOnlyWebsocket).call(this, url, options));
    _this5.dm = dm;

    _this5.init();

    return _this5;
  }

  _createClass(TqRecvOnlyWebsocket, [{
    key: "init",
    value: function init() {
      var self = this;
      this.on('message', function (payload) {
        if (payload.aid === 'rtn_data') {
          self.dm.mergeData(payload.data);
        }
      });
      this.on('reconnect', function (e) {
        console.log(e);
      });
    }
  }]);

  return TqRecvOnlyWebsocket;
}(TqWebsocket);

/* eslint-disable camelcase */
var QUOTE =
/*#__PURE__*/
function () {
  function QUOTE() {
    _classCallCheck(this, QUOTE);

    this.instrument_id = ''; // 'SHFE.au1906'

    this.datetime = ''; // "2017-07-26 23:04:21.000001" (è¡æä»äº¤ææååºçæ¶é´(åäº¬æ¶é´))

    this._last_price = '-'; // ææ°ä»· NaN

    this.ask_price1 = '-'; // åä¸ä»· NaN

    this.ask_volume1 = '-'; // åä¸é 0

    this.bid_price1 = '-'; // ä¹°ä¸ä»· NaN

    this.bid_volume1 = '-'; // ä¹°ä¸é 0

    this.highest = '-'; // å½æ¥æé«ä»· NaN

    this.lowest = '-'; // å½æ¥æä½ä»· NaN

    this.open = '-'; // å¼çä»· NaN

    this.close = '-'; // æ¶çä»· NaN

    this.average = '-'; // å½æ¥åä»· NaN

    this.volume = '-'; // æäº¤é 0

    this.amount = '-'; // æäº¤é¢ NaN

    this.open_interest = '-'; // æä»é 0

    this.lower_limit = '-'; // è·å NaN

    this.upper_limit = '-'; // æ¶¨å NaN

    this.settlement = '-'; // ç»ç®ä»· NaN

    this.change = '-'; // æ¶¨è·

    this.change_percent = '-'; // æ¶¨è·å¹

    this.strike_price = NaN; // è¡æä»·

    this.pre_open_interest = '-'; // æ¨æä»é

    this.pre_close = '-'; // æ¨æ¶çä»·

    this.pre_volume = '-'; // æ¨æäº¤é

    this._pre_settlement = '-'; // æ¨ç»ç®ä»·

    this.margin = '-'; // æ¯æä¿è¯é

    this.commission = '-'; // æ¯ææç»­è´¹
    // åçº¦æå¡éå¸¦åæ°
    // class: '', // ['FUTURE' 'FUTURE_INDEX' 'FUTURE_CONT']
    // ins_id: '',
    // ins_name: '',
    // exchange_id: '',
    // sort_key: '',
    // expired: false,
    // py: '',
    // product_id: '',
    // product_short_name: '',
    // underlying_product: '',
    // underlying_symbol: '', // æ çåçº¦
    // delivery_year: 0,
    // delivery_month: 0,
    // expire_datetime: 0,
    // trading_time: {},
    // volume_multiple: 0, // åçº¦ä¹æ°
    // price_tick: 0, // åçº¦ä»·æ ¼åä½
    // price_decs: 0, // åçº¦ä»·æ ¼å°æ°ä½æ°
    // max_market_order_volume: 1000, // å¸ä»·åæå¤§ä¸åææ°
    // min_market_order_volume: 1, // å¸ä»·åæå°ä¸åææ°
    // max_limit_order_volume: 1000, // éä»·åæå¤§ä¸åææ°
    // min_limit_order_volume: 1, // éä»·åæå°ä¸åææ°
  }

  _createClass(QUOTE, [{
    key: "setChange",
    value: function setChange() {
      if (Number.isFinite(this._last_price) && Number.isFinite(this._pre_settlement) && this._pre_settlement !== 0) {
        this.change = this._last_price - this._pre_settlement;
        this.change_percent = this.change / this._pre_settlement * 100;
      }
    }
  }, {
    key: "last_price",
    set: function set(p) {
      this._last_price = p;
      this.setChange();
    },
    get: function get() {
      return this._last_price;
    }
  }, {
    key: "pre_settlement",
    set: function set(p) {
      this._pre_settlement = p;
      this.setChange();
    },
    get: function get() {
      return this._pre_settlement;
    }
  }]);

  return QUOTE;
}();

var DataManager =
/*#__PURE__*/
function (_EventEmitter) {
  _inherits(DataManager, _EventEmitter);

  function DataManager() {
    var _this;

    var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, DataManager);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(DataManager).call(this));
    _this._epoch = 0; // æ°æ®çæ¬æ§å¶

    _this._data = data;
    _this._diffs = [];
    return _this;
  }

  _createClass(DataManager, [{
    key: "mergeData",
    value: function mergeData(source) {
      var epochIncrease = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      var deleteNullObj = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
      var sourceArr = Array.isArray(source) ? source : [source];

      if (epochIncrease) {
        // å¦æ _epoch éè¦å¢å ï¼å°±æ¯éè¦è®°ä¸æ¥ diffs
        this._epoch += 1;
        this._diffs = sourceArr;
      }

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = sourceArr[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var item = _step.value;
          // è¿æ»¤æç©ºå¯¹è±¡
          if (item === null || IsEmptyObject(item)) continue;
          DataManager.MergeObject(this._data, item, this._epoch, deleteNullObj);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      if (epochIncrease && this._data._epoch === this._epoch) {
        this.emit('data', null);
      }
    }
    /**
     * å¤æ­ æä¸ªè·¯å¾ä¸ æè æä¸ªæ°æ®å¯¹è±¡ æè¿ææ²¡ææ´æ°
     * @param {Array | Object} pathArray | object
     */

  }, {
    key: "isChanging",
    value: function isChanging(pathArray) {
      // _data ä¸­ï¼åªè½æ¾å°å¯¹è±¡ç±»åä¸­è®°å½ç _epoch
      if (Array.isArray(pathArray)) {
        var d = this._data;

        for (var i = 0; i < pathArray.length; i++) {
          d = d[pathArray[i]];
          if (d._epoch && d._epoch === this._epoch) return true;
          if (d === undefined) return false;
        }

        return false;
      } else if (pathArray && pathArray._epoch) {
        return pathArray._epoch === this._epoch;
      }

      return false;
    }
  }, {
    key: "setDefault",
    value: function setDefault(pathArray) {
      var defaultValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var root = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this._data;
      return DataManager.SetDefault(root, pathArray, defaultValue);
    }
  }, {
    key: "getByPath",
    value: function getByPath(pathArray) {
      var root = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._data;
      return DataManager.GetByPath(root, pathArray);
    }
  }]);

  return DataManager;
}(eventemitter3);

DataManager.SetDefault = function (root, pathArray, defaultValue) {
  var node = root;

  for (var i = 0; i < pathArray.length; i++) {
    if (typeof pathArray[i] !== 'string' && typeof pathArray[i] !== 'number') {
      console.error('SetDefault, pathArray ä¸­çåç´ å¿é æ¯ string or number, but pathArray = ', pathArray);
      break;
    }

    var _key = pathArray[i];

    if (!(_key in node)) {
      node[_key] = i === pathArray.length - 1 ? defaultValue : {};
    }

    if (i === pathArray.length - 1) {
      return node[_key];
    } else {
      node = node[_key];
    }
  }

  return node;
};

DataManager.GetByPath = function (root, pathArray) {
  var d = root;

  for (var i = 0; i < pathArray.length; i++) {
    d = d[pathArray[i]];
    if (d === undefined || d === null) return d;
  }

  return d;
};

DataManager.MergeObject = function (target, source) {
  var _epoch = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

  var deleteNullObj = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;

  for (var property in source) {
    var value = source[property];

    var type = _typeof(value);
    /**
     * 1 'string', 'boolean', 'number'
     * 2 'object' åæ¬äº null , Array, {} æå¡å¨ä¸ä¼åé Array
     * 3 'undefined' ä¸å¤ç
     */


    if (['string', 'boolean', 'number'].includes(type)) {
      target[property] = value === 'NaN' ? NaN : value;
    } else if (value === null && deleteNullObj) {
      delete target[property]; // æå¡å¨ è¦æ± å é¤å¯¹è±¡
    } else if (Array.isArray(value)) {
      target[property] = value; // å¦ææ¯æ°ç»ç±»åå°±ç´æ¥æ¿æ¢ï¼å¹¶ä¸è®°å½ _epoch

      if (!value._epoch) {
        Object.defineProperty(value, '_epoch', {
          configurable: false,
          enumerable: false,
          writable: true
        });
      }

      value._epoch = _epoch;
    } else if (type === 'object') {
      // @note: è¿éåäºä¸ä¸ªç¹ä¾, ä½¿å¾ K çº¿åºåæ°æ®è¢«ä¿å­ä¸ºä¸ä¸ª array, èé object
      target[property] = target[property] || (property === 'data' ? [] : {}); // quotes å¯¹è±¡åç¬å¤ç

      if (property === 'quotes') {
        for (var symbol in value) {
          var quote = value[symbol]; // source[property]

          if (quote === null) {
            // æå¡å¨ è¦æ± å é¤å¯¹è±¡
            if (deleteNullObj && symbol) delete target[property][symbol];
            continue;
          } else if (!target[property][symbol]) {
            target[property][symbol] = new QUOTE();
          }

          DataManager.MergeObject(target[property][symbol], quote, _epoch, deleteNullObj);
        }
      } else {
        DataManager.MergeObject(target[property], value, _epoch, deleteNullObj);
      }
    }
  } // _epoch ä¸åºè¯¥è¢«å¾ªç¯å°ç key


  if (!target._epoch) {
    Object.defineProperty(target, '_epoch', {
      configurable: false,
      enumerable: false,
      writable: true
    });
  }

  target._epoch = _epoch;
};

/**
 * äºä»¶ç±»å
 + ready: æ¶å°åçº¦åºç¡æ°æ®ï¼å¨å±åªåºåä¸æ¬¡ï¼
 + rtn_brokers: æ¶å°æè´§å¬å¸åè¡¨ï¼å¨å±åªåºåä¸æ¬¡ï¼
 + notify: æ¶å°éç¥å¯¹è±¡
 + rtn_data: æ°æ®æ´æ°ï¼æ¯ä¸æ¬¡æ°æ®æ´æ°è§¦åï¼
 + error: åçéè¯¯(ç®ååªæä¸ç§ï¼åçº¦æå¡ä¸è½½å¤±è´¥)
 */
// æ¯æå¤è´¦æ·ç»å½

var TQSDK =
/*#__PURE__*/
function (_EventEmitter) {
  _inherits(TQSDK, _EventEmitter);

  function TQSDK() {
    var _this;

    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$symbolsServerUrl = _ref.symbolsServerUrl,
        symbolsServerUrl = _ref$symbolsServerUrl === void 0 ? 'https://openmd.shinnytech.com/t/md/symbols/latest.json' : _ref$symbolsServerUrl,
        _ref$wsQuoteUrl = _ref.wsQuoteUrl,
        wsQuoteUrl = _ref$wsQuoteUrl === void 0 ? 'wss://openmd.shinnytech.com/t/md/front/mobile' : _ref$wsQuoteUrl,
        _ref$wsTradeUrl = _ref.wsTradeUrl,
        wsTradeUrl = _ref$wsTradeUrl === void 0 ? 'wss://opentd.shinnytech.com/trade/user0' : _ref$wsTradeUrl,
        _ref$clientSystemInfo = _ref.clientSystemInfo,
        clientSystemInfo = _ref$clientSystemInfo === void 0 ? '' : _ref$clientSystemInfo,
        _ref$clientAppId = _ref.clientAppId,
        clientAppId = _ref$clientAppId === void 0 ? '' : _ref$clientAppId,
        _ref$autoInit = _ref.autoInit,
        autoInit = _ref$autoInit === void 0 ? true : _ref$autoInit,
        _ref$data = _ref.data,
        data = _ref$data === void 0 ? {
      klines: {},
      quotes: {},
      charts: {},
      ticks: {},
      trade: {}
    } : _ref$data;

    _classCallCheck(this, TQSDK);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(TQSDK).call(this));
    _this._insUrl = symbolsServerUrl;
    _this._mdUrl = wsQuoteUrl;
    _this._tdUrl = wsTradeUrl;
    _this.clientSystemInfo = clientSystemInfo;
    _this.clientAppIds = clientAppId;
    _this._prefix = 'TQJS_';

    var self = _assertThisInitialized(_this);

    _this.dm = new DataManager(data);

    _this.dm.on('data', function () {
      self.emit('rtn_data', null);
    });

    _this.brokers = null;
    _this.trade_accounts = {}; // æ·»å è´¦æ·

    _this.isReady = false;
    _this.quotesWs = null;
    _this.quotesInfo = {};

    if (autoInit) {
      _this.init(); // èªå¨æ§è¡åå§å

    }

    return _this;
  }

  _createClass(TQSDK, [{
    key: "init",
    value: function init() {
      this.initMdWebsocket();
      this.initTdWebsocket();
      var self = this;
      axios.get(this._insUrl, {
        headers: {
          Accept: 'application/json; charset=utf-8'
        }
      }).then(function (response) {
        self.quotesInfo = response.data; // å»ºç«è¡æè¿æ¥

        self.isReady = true;
        self.emit('ready');
        self.emit('rtn_data', null);
      })["catch"](function (error) {
        self.emit('error', error);
        console.error('Error: ' + error.message);
        return error;
      });
    }
  }, {
    key: "initMdWebsocket",
    value: function initMdWebsocket() {
      this.quotesWs = new TqQuoteWebsocket(this._mdUrl, this.dm);
    }
  }, {
    key: "initTdWebsocket",
    value: function initTdWebsocket() {
      //     if broker_id not in broker_list:
      //     raise Exception("ä¸æ¯æè¯¥æè´§å¬å¸-%sï¼è¯·èç³»æè´§å¬å¸ã" % (broker_id))
      // if "TQ" not in broker_list[broker_id]["category"]:
      //     raise Exception("ä¸æ¯æè¯¥æè´§å¬å¸-%sï¼è¯·èç³»æè´§å¬å¸ã" % (broker_id))
      // self._td_url = broker_list[broker_id]["url"]
      var self = this; // æ¯æåæ£é¨ç½²çäº¤æä¸­ç»§ç½å³

      axios.get('https://files.shinnytech.com/broker-list.json', {
        headers: {
          Accept: 'application/json; charset=utf-8'
        }
      }).then(function (response) {
        self.brokers_list = response.data;
        self.brokers = Object.keys(response.data);
        self.emit('rtn_brokers', self.brokers);
        console.log(self.brokers);
      })["catch"](function (error) {
        self.emit('error', error);
        console.error('Error: ' + error.message);
        return error;
      });
    }
  }, {
    key: "addWebSocket",
    value: function addWebSocket() {
      var url = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
      if (url) return new TqRecvOnlyWebsocket(url, this.dm);
      return null;
    } // user_id ä½ä¸ºå¯ä¸ key

  }, {
    key: "addAccount",
    value: function addAccount(bid, userId, password) {
      if (bid && userId && password) {
        if (this.brokers.indexOf(bid) === -1) {
          console.error('ä¸æ¯æè¯¥æè´§å¬å¸');
          return;
        }

        if (!this.trade_accounts[userId]) {
          console.log(this.brokers_list[bid].url);
          var ws = new TqTradeWebsocket(this.brokers_list[bid].url, this.dm);
          var self = this;
          ws.on('notify', function (n) {
            self.emit('notify', Object.assign(n, {
              bid: bid,
              user_id: userId
            }));
          });
          this.trade_accounts[userId] = {
            bid: bid,
            userId: userId,
            password: password,
            ws: ws
          };
        }

        return this.trade_accounts[userId];
      } else {
        return null;
      }
    }
  }, {
    key: "removeAccount",
    value: function removeAccount(bid, userId) {
      if (bid && userId) {
        if (this.trade_accounts[userId]) {
          // close ç¸åºç websocket
          this.trade_accounts[userId].ws.close();
          delete this.trade_accounts[userId]; // å é¤ç¨æ·ç¸åºçæ°æ®

          delete this.dm._data.trade[userId];
        }
      }
    }
  }, {
    key: "updateData",
    value: function updateData(data) {
      this.dm.mergeData(data, true, false);
    }
  }, {
    key: "getByPath",
    value: function getByPath(_path) {
      return this.dm.getByPath(_path);
    }
    /** ***************** è¡ææ¥å£ get_quotes_by_input ********************/

  }, {
    key: "getQuotesByInput",
    value: function getQuotesByInput(_input) {
      if (typeof _input !== 'string' && !_input.input) return [];
      var option = {
        input: typeof _input === 'string' ? _input.toLowerCase() : _input.input.toLowerCase(),
        instrument_id: _input.instrument_id ? _input.instrument_id : true,
        // æ¯å¦æ ¹æ®åçº¦IDå¹é
        pinyin: _input.pinyin ? _input.pinyin : true,
        // æ¯å¦æ ¹æ®æ¼é³å¹é
        include_expired: _input.include_expired ? _input.include_expired : false,
        // å¹éç»ææ¯å¦åå«å·²ä¸å¸åçº¦
        FUTURE: _input.future ? !!_input.future : true,
        // å¹éç»ææ¯å¦åå«æè´§åçº¦
        FUTURE_INDEX: _input.future_index ? !!_input.future_index : false,
        // å¹éç»ææ¯å¦åå«æè´§ææ°
        FUTURE_CONT: _input.future_cont ? !!_input.future_cont : false,
        // å¹éç»ææ¯å¦åå«æè´§ä¸»è¿
        OPTION: _input.option ? !!_input.option : false,
        // å¹éç»ææ¯å¦åå«ææ
        COMBINE: _input.combine ? !!_input.combine : false // å¹éç»ææ¯å¦åå«ç»å

      };

      var filterSymbol = function filterSymbol(filterOption, quote, by) {
        if (filterOption[quote["class"]] && (filterOption.include_expired || !filterOption.include_expired && !quote.expired)) {
          if (by === 'instrument_id') {
            if (quote.product_id.toLowerCase() === filterOption.input) {
              return true;
            } else if (filterOption.input.length > 2 && quote.instrument_id.toLowerCase().indexOf(filterOption.input) > -1) {
              return true;
            } else {
              return false;
            }
          } else if (by === 'pinyin' && quote.py.split(',').indexOf(filterOption.input) > -1) {
            return true;
          } else {
            return false;
          }
        }

        return false;
      };

      var result = [];

      if (option.instrument_id) {
        for (var symbol in this.quotesInfo) {
          if (filterSymbol(option, this.quotesInfo[symbol], 'instrument_id')) {
            result.push(symbol);
          }
        }
      }

      if (option.pinyin) {
        for (var _symbol in this.quotesInfo) {
          if (filterSymbol(option, this.quotesInfo[_symbol], 'pinyin')) {
            result.push(_symbol);
          }
        }
      }

      return result;
    }
    /** ***************** è¡ææ¥å£ get_quote ********************/

  }, {
    key: "getQuote",
    value: function getQuote(symbol) {
      if (symbol === '') return {};
      var symbolObj = this.dm.setDefault(['quotes', symbol], new QUOTE());

      if (!symbolObj["class"] && this.quotesInfo[symbol]) {
        // quotesInfo ä¸­ç last_price
        // eslint-disable-next-line camelcase
        var last_price = symbolObj.last_price ? symbolObj.last_price : this.quotesInfo[symbol].last_price;
        Object.assign(symbolObj, this.quotesInfo[symbol], {
          last_price: last_price
        });
      }

      return symbolObj;
    }
    /** ***************** è¡ææ¥å£ set_chart ********************/

  }, {
    key: "setChart",
    value: function setChart(payload) {
      var content = {};

      if (payload.trading_day_start || payload.trading_day_count) {
        // æå®äº¤ææ¥ï¼è¿åå¯¹åºçæ°æ®
        content.trading_day_start = payload.trading_day_start ? payload.trading_day_start : 0; // trading_day_count è¯·æ±äº¤ææ¥å¤©æ°

        content.trading_day_count = payload.trading_day_count ? payload.trading_day_count : 3600 * 24 * 1e9;
      } else {
        content.view_width = payload.view_width ? payload.view_width : 500;

        if (payload.left_kline_id) {
          // æå®ä¸ä¸ªKçº¿idï¼åå³è¯·æ±Nä¸ªæ°æ®
          content.left_kline_id = payload.left_kline_id;
        } else if (payload.focus_datetime) {
          // ä½¿å¾æå®æ¥æçKçº¿ä½äºå±å¹ç¬¬Mä¸ªæ±å­çä½ç½®
          content.focus_datetime = payload.focus_datetime; // æ¥çº¿åä»¥ä¸å¨ææ¯äº¤ææ¥ï¼å¶ä»å¨ææ¯æ¶é´ï¼UnixNano åäº¬æ¶é´

          content.focus_position = payload.focus_position ? payload.focus_position : 0;
        }
      }

      this.quotesWs.send(Object.assign({
        aid: 'set_chart',
        chart_id: payload.chart_id ? payload.chart_id : this._prefix + 'kline_chart',
        ins_list: payload.ins_list ? payload.ins_list.join(',') : payload.symbol,
        duration: payload.duration
      }, content));
    }
    /** ***************** äº¤ææ¥å£ get_user ********************/

  }, {
    key: "getUser",
    value: function getUser(payload) {
      var userId = typeof payload === 'string' ? payload : payload.user_id;
      return userId ? this.dm._data.trade[userId] : null;
    }
    /** ***************** æ¥å£ get ********************/

  }, {
    key: "get",
    value: function get() {
      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref2$name = _ref2.name,
          name = _ref2$name === void 0 ? 'users' : _ref2$name,
          _ref2$user_id = _ref2.user_id,
          user_id = _ref2$user_id === void 0 ? '' : _ref2$user_id,
          _ref2$currency = _ref2.currency,
          currency = _ref2$currency === void 0 ? 'CNY' : _ref2$currency,
          _ref2$symbol = _ref2.symbol,
          symbol = _ref2$symbol === void 0 ? '' : _ref2$symbol,
          _ref2$order_id = _ref2.order_id,
          order_id = _ref2$order_id === void 0 ? '' : _ref2$order_id,
          _ref2$trade_id = _ref2.trade_id,
          trade_id = _ref2$trade_id === void 0 ? '' : _ref2$trade_id,
          _ref2$trading_day = _ref2.trading_day,
          trading_day = _ref2$trading_day === void 0 ? '' : _ref2$trading_day,
          _ref2$chart_id = _ref2.chart_id,
          chart_id = _ref2$chart_id === void 0 ? '' : _ref2$chart_id,
          _ref2$input = _ref2.input,
          input = _ref2$input === void 0 ? '' : _ref2$input,
          _ref2$duration = _ref2.duration,
          duration = _ref2$duration === void 0 ? 0 : _ref2$duration;

      if (name === 'users') {
        return Object.keys(this.trade_accounts);
      }

      if (user_id) {
        // get äº¤æç¸å³æ°æ®
        var user = this.get_user(user_id);

        if (name === 'user') {
          return user;
        }

        if (['session', 'accounts', 'positions', 'orders', 'trades', 'his_settlements'].indexOf(name) > -1) {
          return user && user[name] ? user[name] : null;
        } else if (user && user[name + 's']) {
          var k = name === 'account' ? currency : name === 'position' ? symbol : name === 'order' ? order_id : name === 'trade' ? trade_id : name === 'his_settlement' ? trading_day : '';
          return user[name + 's'][k];
        }

        return null;
      } else {
        // get è¡æç¸å³æ°æ®
        if (name === 'quotes') {
          return input ? this.get_quotes_by_input(input) : [];
        }

        if (name === 'quote') return this.getQuote(symbol);
        if (name === 'klines') return this.getKlines(symbol, duration);
        if (name === 'ticks') return this.getTicks(symbol);
        if (name === 'charts') return this.dm.getByPath(['charts']);
        if (name === 'chart') return this.dm.getByPath(['charts', chart_id]);
      }
    }
  }, {
    key: "getKlines",
    value: function getKlines(symbol, dur) {
      if (symbol === '') return null;
      var ks = this.dm.getByPath(['klines', symbol, dur]);

      if (!ks || !ks.data || ks.last_id === -1) {
        this.dm.mergeData({
          klines: _defineProperty({}, symbol, _defineProperty({}, dur, {
            last_id: -1,
            data: {}
          }))
        }, false, false);
        ks = this.dm.getByPath(['klines', symbol, dur]);
      }

      return ks;
    }
  }, {
    key: "getTicks",
    value: function getTicks(symbol) {
      if (symbol === '') return null;
      var ts = this.dm.getByPath(['ticks', symbol]);

      if (!ts || !ts.data) {
        this.dm.mergeData({
          ticks: _defineProperty({}, symbol, {
            last_id: -1,
            data: {}
          })
        }, false, false);
      }

      return this.dm.getByPath(['ticks', symbol]);
    }
  }, {
    key: "isLogined",
    value: function isLogined(payload) {
      var session = this.get({
        name: 'session',
        user_id: payload.user_id
      });
      return !!(session && session.trading_day);
    }
  }, {
    key: "isChanging",
    value: function isChanging(target, source) {
      if (target && target._epoch) return target._epoch === this.dm._epoch;
      if (typeof target === 'string') return this.dm.isChanging(target, source);
      return false;
    }
  }, {
    key: "insertOrder",
    value: function insertOrder(payload) {
      if (!this.is_logined(payload)) return null;
      var orderId = this._prefix + RandomStr(8);
      var _order_common = {
        user_id: payload.user_id,
        orderId: orderId,
        exchange_id: payload.exchange_id,
        instrument_id: payload.ins_id,
        direction: payload.direction,
        offset: payload.offset,
        price_type: payload.price_type ? payload.price_type : 'LIMIT',
        // "LIMIT" "ANY"
        limit_price: Number(payload.limit_price),
        volume_condition: 'ANY',
        // æ°éæ¡ä»¶ (ANY=ä»»ä½æ°é, MIN=æå°æ°é, ALL=å¨é¨æ°é)
        time_condition: payload.price_type === 'ANY' ? 'IOC' : 'GFD' // æ¶é´æ¡ä»¶ (IOC=ç«å³å®æï¼å¦åæ¤é, GFS=æ¬èææ, *GFD=å½æ¥ææ, GTC=æ¤éåææ, GFA=éåç«ä»·ææ)

      };

      var _orderInsert = Object.assign({
        aid: 'insert_order',
        volume: payload.volume
      }, _order_common);

      this.trade_accounts[payload.user_id].ws.send(_orderInsert);

      var _orderInit = Object.assign({
        volume_orign: payload.volume,
        // æ»æ¥åææ°
        // å§æåå½åç¶æ
        status: 'ALIVE',
        // å§æåç¶æ, (ALIVE=ææ, FINISHED=å·²å®)
        volume_left: payload.volume // æªæäº¤ææ°

      }, _order_common);

      this.dm.mergeData({
        trade: _defineProperty({}, payload.user_id, {
          orders: _defineProperty({}, orderId, _orderInit)
        })
      }, false, false);
      return this.get({
        name: 'order',
        user_id: payload.user_id,
        orderId: orderId
      });
    }
  }, {
    key: "autoInsertOrder",
    value: function autoInsertOrder(payload) {
      if (!this.is_logined(payload)) return null;
      /* payload : {symbol, exchange_id, ins_id, direction, price_type, limit_price, offset, volume} */

      var initOrder = {
        user_id: payload.user_id,
        price_type: payload.price_type ? payload.price_type : 'LIMIT',
        // "LIMIT" "ANY"
        volume_condition: 'ANY',
        time_condition: payload.price_type === 'ANY' ? 'IOC' : 'GFD',
        exchange_id: payload.exchange_id,
        instrument_id: payload.ins_id,
        direction: payload.direction,
        limit_price: Number(payload.limit_price)
      };

      if (payload.exchange_id === 'SHFE' && payload.offset === 'CLOSE') {
        var position = this.dm.getPosition(payload.symbol, payload.user_id); // æåï¼åå¹³ä»åå¹³æ¨

        var closeTodayVolume = 0;

        if (payload.direction === 'BUY' && position.volume_short_today > 0) {
          closeTodayVolume = Math.min(position.volume_short_today, payload.volume);
        } else if (payload.direction === 'SELL' && position.volume_long_today > 0) {
          closeTodayVolume = Math.min(position.volume_long_today, payload.volume);
        }

        if (closeTodayVolume > 0) {
          this.insert_order(Object.assign({
            offset: 'CLOSETODAY',
            volume: closeTodayVolume
          }, initOrder));
        }

        if (payload.volume - closeTodayVolume > 0) {
          this.insert_order(Object.assign({
            offset: 'CLOSE',
            volume: payload.volume - closeTodayVolume
          }, initOrder));
        }
      } else {
        this.insert_order(Object.assign({
          offset: payload.offset,
          volume: payload.volume
        }, initOrder));
      }
    }
  }, {
    key: "cancelOrder",
    value: function cancelOrder(payload) {
      this.trade_accounts[payload.user_id].ws.send({
        aid: 'cancel_order',
        user_id: payload.user_id,
        order_id: payload.order_id ? payload.order_id : payload
      });
    } // ç»å½

  }, {
    key: "login",
    value: function login(payload) {
      this.trade_accounts[payload.user_id].ws.send({
        aid: 'req_login',
        bid: payload.bid,
        user_name: payload.user_id,
        password: payload.password,
        client_system_info: this.clientSystemInfo,
        client_app_id: this.clientAppId
      });
    } // ç¡®è®¤ç»ç®å

  }, {
    key: "confirmSettlement",
    value: function confirmSettlement(payload) {
      this.trade_accounts[payload.user_id].ws.send({
        aid: 'confirm_settlement'
      });
    } // é¶æè½¬è´¦

  }, {
    key: "transfer",
    value: function transfer(payload) {
      this.trade_accounts[payload.user_id].ws.send({
        aid: 'req_transfer',
        bank_id: payload.bank_id,
        // é¶è¡ID
        bank_password: payload.bank_password,
        // é¶è¡è´¦æ·å¯ç 
        future_account: payload.future_account,
        // æè´§è´¦æ·
        future_password: payload.future_password,
        // æè´§è´¦æ·å¯ç 
        currency: 'CNY',
        // å¸ç§ä»£ç 
        amount: payload.amount // è½¬è´¦éé¢, >0 è¡¨ç¤ºè½¬å¥æè´§è´¦æ·, <0 è¡¨ç¤ºè½¬åºæè´§è´¦æ·

      });
    } // åå²ç»ç®å

  }, {
    key: "hisSettlement",
    value: function hisSettlement(payload) {
      if (!TQSDK.store) return null; // åå²ç»ç®å è¯»åä¼åçº§ï¼ dm -> ç¼å­(åå¥dm) -> æå¡å¨(åå¥dmãç¼å­)
      // ç¼å­ç­ç¥ 1 dmæåå²ç»ç®å

      var content = this.dm.getByPath(['trade', payload.user_id, 'his_settlements', payload.trading_day]);
      if (content !== undefined) return; // ç¼å­ç­ç¥ 2 ç¼å­ä¸­è¯»ååå²ç»ç®å

      var self = this;
      content = TQSDK.store.getContent(payload.user_id, payload.trading_day).then(function (value) {
        if (value === null) {
          // ç¼å­ç­ç¥ 2.1 æªè¯»åå°åéè¯·æ±
          self.trade_accounts[payload.user_id].ws.send({
            aid: 'qry_settlement_info',
            trading_day: Number(payload.trading_day)
          });
        } else {
          var _content = ParseSettlementContent(value); // ç¼å­ç­ç¥ 2.2 è¯»åå°å­å°dm


          self.dm.mergeData({
            trade: _defineProperty({}, payload.user_id, {
              his_settlements: _defineProperty({}, payload.trading_day, _content)
            })
          }, true, false);
        }
      })["catch"](function (err) {
        // å½åºéæ¶ï¼æ­¤å¤ä»£ç è¿è¡
        console.error(err);
      });
    }
  }, {
    key: "subscribeQuote",
    value: function subscribeQuote(quotes) {
      this.quotesWs.send({
        aid: 'subscribe_quote',
        ins_list: Array.isArray(quotes) ? quotes.join(',') : quotes
      });
    }
  }]);

  return TQSDK;
}(eventemitter3); // ä¿çååå°å¯«å ä¸åç¶«æ¥å£,æ°å¢æ¥å£é½æ¯é§å³°æ¨èª


TQSDK.prototype.subscribe_quote = TQSDK.prototype.subscribeQuote;
TQSDK.prototype.his_settlement = TQSDK.prototype.hisSettlement;
TQSDK.prototype.confirm_settlement = TQSDK.prototype.confirmSettlement;
TQSDK.prototype.add_account = TQSDK.prototype.addAccount;
TQSDK.prototype.remove_account = TQSDK.prototype.removeAccount;
TQSDK.prototype.update_data = TQSDK.prototype.updateData;
TQSDK.prototype.get_by_path = TQSDK.prototype.getByPath;
TQSDK.prototype.get_quotes_by_input = TQSDK.prototype.getQuotesByInput;
TQSDK.prototype.get_quote = TQSDK.prototype.getQuote;
TQSDK.prototype.set_chart = TQSDK.prototype.setChart;
TQSDK.prototype.get_user = TQSDK.prototype.getUser;
TQSDK.prototype.is_logined = TQSDK.prototype.isLogined;
TQSDK.prototype.is_changed = TQSDK.prototype.isChanging;
TQSDK.prototype.insert_order = TQSDK.prototype.insertOrder;
TQSDK.prototype.auto_insert_order = TQSDK.prototype.autoInsertOrder;
TQSDK.prototype.cancel_order = TQSDK.prototype.cancelOrder;

TQSDK.TqWebsocket = TqWebsocket;
TQSDK.DataManager = DataManager;
TQSDK.version = version;

export default TQSDK;
